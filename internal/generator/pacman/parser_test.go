package pacman

import (
	"testing"
)

func TestParsePKGINFO(t *testing.T) {
	pkginfoContent := []byte(`# Generated by makepkg
pkgname = nano
pkgbase = nano
pkgver = 8.3-1
pkgdesc = Pico editor clone with enhancements
url = https://www.nano-editor.org
builddate = 1736025597
packager = Andreas Radke <andyrtr@archlinux.org>
size = 2705885
arch = x86_64
license = GPL-3.0-or-later
depend = ncurses
depend = file
depend = glibc
`)

	pkg, err := parsePKGINFO(pkginfoContent)
	if err != nil {
		t.Fatalf("Failed to parse PKGINFO: %v", err)
	}

	// Check basic fields
	if pkg.Name != "nano" {
		t.Errorf("Expected name 'nano', got '%s'", pkg.Name)
	}

	if pkg.Version != "8.3-1" {
		t.Errorf("Expected version '8.3-1', got '%s'", pkg.Version)
	}

	if pkg.Architecture != "x86_64" {
		t.Errorf("Expected architecture 'x86_64', got '%s'", pkg.Architecture)
	}

	if pkg.Description != "Pico editor clone with enhancements" {
		t.Errorf("Expected description 'Pico editor clone with enhancements', got '%s'", pkg.Description)
	}

	if pkg.Homepage != "https://www.nano-editor.org" {
		t.Errorf("Expected homepage 'https://www.nano-editor.org', got '%s'", pkg.Homepage)
	}

	if pkg.License != "GPL-3.0-or-later" {
		t.Errorf("Expected license 'GPL-3.0-or-later', got '%s'", pkg.License)
	}

	if pkg.Maintainer != "Andreas Radke <andyrtr@archlinux.org>" {
		t.Errorf("Expected maintainer 'Andreas Radke <andyrtr@archlinux.org>', got '%s'", pkg.Maintainer)
	}

	// Check dependencies
	expectedDeps := []string{"ncurses", "file", "glibc"}
	if len(pkg.Dependencies) != len(expectedDeps) {
		t.Errorf("Expected %d dependencies, got %d", len(expectedDeps), len(pkg.Dependencies))
	}

	for i, dep := range expectedDeps {
		if i >= len(pkg.Dependencies) || pkg.Dependencies[i] != dep {
			t.Errorf("Expected dependency[%d] '%s', got '%s'", i, dep, pkg.Dependencies[i])
		}
	}

	// Check metadata
	if buildDate, ok := pkg.Metadata["BuildDate"].(string); !ok || buildDate != "1736025597" {
		t.Errorf("Expected BuildDate '1736025597', got '%v'", pkg.Metadata["BuildDate"])
	}

	if installedSize, ok := pkg.Metadata["InstalledSize"].(string); !ok || installedSize != "2705885" {
		t.Errorf("Expected InstalledSize '2705885', got '%v'", pkg.Metadata["InstalledSize"])
	}
}

func TestParsePKGINFOMinimal(t *testing.T) {
	pkginfoContent := []byte(`pkgname = test-package
pkgver = 1.0.0-1
arch = any
`)

	pkg, err := parsePKGINFO(pkginfoContent)
	if err != nil {
		t.Fatalf("Failed to parse minimal PKGINFO: %v", err)
	}

	if pkg.Name != "test-package" {
		t.Errorf("Expected name 'test-package', got '%s'", pkg.Name)
	}

	if pkg.Version != "1.0.0-1" {
		t.Errorf("Expected version '1.0.0-1', got '%s'", pkg.Version)
	}

	if pkg.Architecture != "any" {
		t.Errorf("Expected architecture 'any', got '%s'", pkg.Architecture)
	}
}

func TestSanitizeRepoName(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"test-repo", "test-repo"},
		{"Test Repo", "test-repo"},
		{"TEST_REPO", "test-repo"},
		{"repo@123", "repo-123"},
		{"my/repo", "my-repo"},
		{"repo.name", "repo-name"},
	}

	for _, tt := range tests {
		result := sanitizeRepoName(tt.input)
		if result != tt.expected {
			t.Errorf("sanitizeRepoName(%q) = %q, want %q", tt.input, result, tt.expected)
		}
	}
}
